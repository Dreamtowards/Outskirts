cge log

191204
    + Illuminable::getLights()

191205
    + init.Sounds
    + GameSettings.ENABLE_FA
    + AudioSource::unqueueAllBuffers()
    + GuiButton, have sounding, GuiText::updateTextToCenter()
    + GuiDrag

    tk Illuminable::calculateLights() [?]: get just simple getting, partial calculation ?
       Light: light should be use in ServerSide..?
       Gui/Event: why Gui not use event.EventBus ..?


191206
    Gui::forChildren being to Instanced. solved when for-event's children removal exception

    tk
    #why use Octree..
    does it really working good? it provide a pretty good block-cell, but being a lot of complexity
    like getting to diff size.. it being a lot of storage free, but also some loose
    we can't use fixed high precision voxel like slot unit=10cm, that is temporary way.

191208
    + CopyOnReadArrayList

    tk
    no Event::unregisterCurrentHandler. cause this is surface/local/high-level operation, that needs register new handler also

191210
      CopyOnIterateArrayList
    + event.gui.GuiEvent
    + EventBus::handlerListFactory

191219
    + Quaternion::toMatrix(Quaternion, Matrix4f), Quaternion::rotate(Quaternion, Matrix3f/4f)
    + Matrix3f::rotate
      Maths matrix creation calculations
    + Maths::toRadians, toDegrees
      Camera::getPosition() getRotation()
      outskirts.physics.Transform -> outskirts.util.Transform



TodoList:
  - Font/Scale
  - Event - Async ..?






















removed temp


    private static byte[] encrypt(byte[] origin, byte[] key) throws Exception {
        SecretKey secretKey = new SecretKeySpec(key, "AES");

        Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding");
        cipher.init(Cipher.ENCRYPT_MODE, secretKey);
        return cipher.doFinal(origin);
    }

    private static byte[] decrypt(byte[] encrypted, byte[] key) throws Exception {
        SecretKey secretKey = new SecretKeySpec(key, "AES");

        Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding");
        cipher.init(Cipher.DECRYPT_MODE, secretKey);
        return cipher.doFinal(encrypted);
    }



//            Vector2f textureOffset = new Vector2f(
//                    ch % 16 / 16f,
//                    1f - ((int)(ch % 256 / 16) / 16f) - 1f/16f
//            );
//            shader.setVector2f("textureOffset[" + i + "]", textureOffset);



            LocalDateTime localDateTime = LocalDateTime.parse(timeStr, DateTimeFormatter.ofPattern("yyyy-MM-dd-HH-mm-ss-SSS"));
            long millis = localDateTime
                    .atZone(ZoneId.systemDefault())
                    .toInstant().toEpochMilli();




// how about Map<String, Integer>GameSettings.SHADER_DEFINES or SHADER_REPLACES

        for (Map.Entry<String, Object> entry : GameSettings.ShaderDefines.getDefines().entrySet()) {
            String defineSigns = "#define " + entry.getKey();
            if (shaderSource.contains(defineSigns)) {
                String defined = "#define " + entry.getKey() + " " + entry.getValue();
                shaderSource = shaderSource.replace(defineSigns, defined);
                Log.info("Load shader define " + defined);
            }
        }

    public static class ShaderDefines {

        public static int FONT_INSTANCE_MAX = 64;

        public static Map<String, Object> getDefines() {
            try {
                Map<String, Object> map = new HashMap<>();
                for (Field field : ShaderDefines.class.getFields()) {
                    map.put(field.getName(), field.get(ShaderDefines.class));
                }
                return map;
            } catch (IllegalAccessException ex) {
                throw new RuntimeException("Impossible exception");
            }
        }
    }





deprecated: unnecessary complexity
/**
 * A mainly function is using interface default-get/set override to support Vector3i
 * and the bad fact is non-necessary and within more complexity,
 * because block-accessing operate is mostly depend that Object(likes World/Chunk..) while not this Interface
 */

public interface BlockAccessible {

    void setBlockState(int x, int y, int z, BlockState blockState);

    default void setBlockState(Vector3i blockPos, BlockState blockState) {
        setBlockState(blockPos.x, blockPos.y, blockPos.z, blockState);
    }



    BlockState getBlockState(int x, int y, int z);

    default BlockState getBlockState(Vector3i blockPos) {
        return getBlockState(blockPos.x, blockPos.y, blockPos.z);
    }

}









    191018

    # world should have block-height-limit? (even negative height world..?

    UNKNOWNS MAKE SERIOUS
    ef have 256 limited, that probably makes you feeling the world is simple and make you non single-minded
    scening to learning the world.

    think unlimited height is much more possibility though you have not a really idea yet,
    you are not in a 256-height wide box, you even can build The-End in 10k-height altitude, or in 2k height
    make fairy-bound islands.


    DOES AUTO-HEIGHT PROFESSIONAL?
    auto-height gives more free space and ways, but also bring some problem, like computing/network load,
    complexity of program/player, and stability of system of program/player.
    some player may not like the complexity(?), may they will feeling some unstable and totally-half untrust
    the world f the system is not pretty great.

    S-N:
    - axis Y always require more inseparable, like shadow-drop, high-fall...
    - high altitude always boring f not content
    - this will make system more complex
    - player'll extra worry high-place problem
    S-P:
    - sounds incredible crazy and free height value(get rid of 256)


    # how high-density blocks storage?

    # how about every-block-instancing

    -jvm common spec: Object MEM: [MarkWord:4/8][ClassPointer:4/8][InstanceData][Padding(*8)] (unit: bytes) (so always nearly 1-3'long)

    actually blocks mainly is Logic and Identify

    MEM AND LOADS
    think f every block is root unit block, that a section have 4096blocks, f y:80- is full, that a
    chunk has 5*4096=20480blocks filled, every block instance has 2int&objRes=2*4+2*8=24bytes. s a chunk=24*20500=500k bytes






//    private ExtendedBlockStorage[] storageArray = new ExtendedBlockStorage[16];







191120

Broadphase removed:

    private List<CollisionObject> broadphaseObjects = new ArrayList<>();

    public CollisionObject createEntry(CollisionObject collisionObject) {
        broadphaseObjects.add(collisionObject);
        return collisionObject;
    }

    public void destroyEntry(CollisionObject entry) {
        broadphaseObjects.remove(entry);

        //pairList.removePairsContainsProxy(wrapped, dispatcher);
    }

DynamicsWorld removed:
    private static final Vector3f CONTACT_THRESHOLD = new Vector3f(0.2f, 0.2f, 0.2f);
    updateAABBs():
            aabb.grow(CONTACT_THRESHOLD);


Test.java rem:

        BufferedImage bufferedImage = new BufferedImage(1024, 1024, BufferedImage.TYPE_INT_ARGB);

        bufferedImage.getGraphics().drawRect(0, 512, 1024, 1);
        bufferedImage.getGraphics().drawRect(512, 0, 1, 1024);
        bufferedImage.getGraphics().drawRect(512+256, 0, 1, 1024);
        bufferedImage.getGraphics().drawRect(512-256, 0, 1, 1024);
        bufferedImage.getGraphics().drawRect(0, 512+256, 1024, 1);
        bufferedImage.getGraphics().drawRect(0, 512-256, 1024, 1);
        for (int i = 0;i < 1024;i++) {
            int x = i - 512;

            int y = (int)((1-Maths.powerease(1-x/256f, 3)) * 256);

            bufferedImage.getGraphics().drawRect(i, 512-y, 1, 1);
        }
        ImageIO.write(bufferedImage, "PNG", new File("out.png"));



191124
Gui.java rem:
    public static class Transform {
        private float duration;
        private float passed = 0;
        private int from;
        private int to;
        private Consumer<Integer> updater;
        private TriFunction<Float, Integer, Integer, Float> interpolator;

        public static final TriFunction<Float, Integer, Integer, Float> ITP_BACKEASE = (t, s, e) -> Maths.lerp(Maths.powerease(t, 1), s, e);

        /**
         * @param duration seconds
         * @param updater the interpolation value applicator
         * @param interpolator the interpolation generator, return interpolation value, args: translation-performing-percent(0.0-1.0), from, to
         */
        public Transform(int from, int to, float duration, Consumer<Integer> updater, TriFunction<Float, Integer, Integer, Float> interpolator) {
            this.duration = duration;
            this.from = from;
            this.to = to;
            this.updater = updater;
            this.interpolator = interpolator;
        }

        /**
         * @return true if should remove this transform (done the transformation)
         */
        private boolean apply(float delta) {
            passed += delta;
            float percent = passed / duration;

            float v = interpolator.apply(percent, from, to);
            updater.accept((int)v);

            return passed > duration;
        }
    }




Matrix4f.java rotate rem:


//        float t00 = dest.m00 * f00 + dest.m01 * f10 + dest.m02 * f20;
//        float t10 = dest.m10 * f00 + dest.m11 * f10 + dest.m12 * f20;
//        float t20 = dest.m20 * f00 + dest.m21 * f10 + dest.m22 * f20;
//        float t30 = dest.m30 * f00 + dest.m31 * f10 + dest.m32 * f20;
//        float t01 = dest.m00 * f01 + dest.m01 * f11 + dest.m02 * f21;
//        float t11 = dest.m10 * f01 + dest.m11 * f11 + dest.m12 * f21;
//        float t21 = dest.m20 * f01 + dest.m21 * f11 + dest.m22 * f21;
//        float t31 = dest.m30 * f01 + dest.m31 * f11 + dest.m32 * f21;
//        dest.m02 = dest.m00 * f02 + dest.m01 * f12 + dest.m02 * f22;
//        dest.m12 = dest.m10 * f02 + dest.m11 * f12 + dest.m12 * f22;
//        dest.m22 = dest.m20 * f02 + dest.m21 * f12 + dest.m22 * f22;
//        dest.m32 = dest.m30 * f02 + dest.m31 * f12 + dest.m32 * f22;
//        dest.m00 = t00;
//        dest.m10 = t10;
//        dest.m20 = t20;
//        dest.m30 = t30;
//        dest.m01 = t01;
//        dest.m11 = t11;
//        dest.m21 = t21;
//        dest.m31 = t31;







Quaternion:


    private static final int SIGN_X = 0, // order-axis-sign axis/2bit
                             SIGN_Y = 1,
                             SIGN_Z = 2;

    // OP_ORDER_XYZ or OP_EULER_XYZ ..?
    public static final int OP_EULER_XYZ = SIGN_X << 4 | SIGN_Y << 2 | SIGN_Z;

    public static Quaternion fromEuler(Vector3f euler, int order, Quaternion dest) {
        if (dest == null)
            dest = new Quaternion();

        float cx = (float)Math.cos(euler.x / 2f);
        float cy = (float)Math.cos(euler.y / 2f);
        float cz = (float)Math.cos(euler.z / 2f);
        float sx = (float)Math.sin(euler.x / 2f);
        float sy = (float)Math.sin(euler.y / 2f);
        float sz = (float)Math.sin(euler.z / 2f);

        if (order == OP_EULER_XYZ) {
//            dest.x = cz * sx * cy + sz * cx * sy;
//            dest.y = cz * cx * sy - sz * sx * cy;
//            dest.z = sy * sx * cz + cy * cx * sz;
//            dest.w = cy * cx * cz - sy * sx * sz;
            dest.x = sz*cx*cy - cz*sx*sy;
            dest.y = cz*sx*cy + sz*cx*sy;
            dest.z = cz*cx*sy - sz*sx*cy;
            dest.w = cz*cx*cy + sz*sx*sy;
        } else {
            throw new UnsupportedOperationException(String.format("Unsupported euler order. (%s)", order));
        }

        return dest;
    }

    public static Vector3f toEuler(Quaternion q, int order, Vector3f dest) {
        if (dest == null)
            dest = new Vector3f();

        if (order == OP_EULER_XYZ) {
//            dest.x = (float) Math.atan2(-2*(q.y*q.z - q.w*q.x), q.w*q.w - q.x*q.x - q.y*q.y + q.z*q.z);
//            dest.y = (float) Math.asin(2*(q.x*q.z + q.w*q.y));
//            dest.z = (float) Math.atan2(-2*(q.x*q.y - q.w*q.z), q.w*q.w + q.x*q.x - q.y*q.y - q.z*q.z);

            dest.z = (float) Math.atan2(2f * (q.w*q.x + q.y*q.z), 1f - 2f * (q.x*q.x + q.y*q.y)); //roll
            dest.x = (float) Math.asin(Maths.clamp(2f * (q.w*q.y - q.z*q.x), -1f, 1f)); //pitch
            dest.y = (float) Math.atan2(2f * (q.w*q.z + q.x*q.y), 1f - 2f * (q.y*q.y + q.z*q.z)); //yaw
        } else {
            throw new UnsupportedOperationException(String.format("Unsupported euler order. (%s)", order));
        }

        return dest;
    }



Maths::createViewMatrix


//        float pitch = rotation.x, yaw = rotation.y, roll = rotation.z;
//        Matrix4f.rotate((float) Math.toRadians(pitch), Vector3f.UNIT_X, viewMatrix);
//        Matrix4f.rotate((float) Math.toRadians(yaw),   Vector3f.UNIT_Y, viewMatrix);
//        Matrix4f.rotate((float) Math.toRadians(roll),  Vector3f.UNIT_Z, viewMatrix);




//        //TOD-O: judgment rotation is zero to ignore RotateMatrix?
//        Matrix4f.rotate((float) Math.toRadians(rotation.x), Vector3f.UNIT_X, modelMatrix);
//        Matrix4f.rotate((float) Math.toRadians(rotation.y), Vector3f.UNIT_Y, modelMatrix);
//        Matrix4f.rotate((float) Math.toRadians(rotation.z), Vector3f.UNIT_Z, modelMatrix);



Chunk.java


    public void setBlockState(float x, float y, float z, int depth, BlockState blockState) {

        getOctree(x, y, z, depth, Octree.GettingType.CREATING).body(blockState);
    }

    public BlockState getBlockState(float x, float y, float z, int depth, Octree.GettingType type) {
        if (y >= SIZE_Y || y < 0) //this can avoid a lots of checking
            return null;

        Octree octree = getOctree(x, y, z, depth, type);

        if (octree == null)
            return null;

        return octree.body();
    }


World.java


    @Nullable
    public BlockState getBlockState(float x, float y, float z, int depth, Octree.GettingType type) {
        Chunk chunk = getLoadedChunk(x, z);

        if (chunk == null)
            return null;

        return chunk.getBlockState(x, y, z, depth, type);
    }

    public void setBlockState(float x, float y, float z, int depth, BlockState blockState) {
        Chunk chunk = getLoadedChunk(x, z);
        Validate.notNull(chunk, "The chunk has not been loaded yet.");

        chunk.setBlockState(x, y, z, depth, blockState);

        Events.EVENT_BUS.post(new BlockChangedEvent(this, new Vector4f(x, y, z, depth)));
    }
    public final void setBlockState(Vector4f blockPos, BlockState blockState) {
        Validate.isTrue(Maths.frac(blockPos.w) == 0, "blockPos.w depth must be integer number");
        setBlockState(blockPos.x, blockPos.y, blockPos.z, (int)blockPos.w, blockState);
    }


RayPicker.java

    private Facing currentBlockFacing;

            if (currentOctree != null) { //really needs..?
                currentBlockFacing = Facing.nearestFacing(collidedAABB, currentPrecisionPoint);
            }

    @Nullable
    public Facing getCurrentBlockFacing() {
        return currentBlockFacing;
    }


191210
EventBus::post

    /**
     * for supports dynamic register/unregister when EventHandler executing.
     * post()'ll not iterate actually Handlers, just iterate the copy of current Handlers.
     * so actually handlers can be dynamic modify(register/unregister) when executing EventHandler(s).
     * length 16 is a init value for avoid dense alloc when several initial posts. actually length'll be max(for : handlers.size)
     */
    private Handler[] tmpExecutionHandlers = new Handler[16];

//        //execute every current EventHandler
//        int s = handlers.size(); //handler.size() might be change when executing handlers
//        tmpExecutionHandlers = handlers.toArray(tmpExecutionHandlers);
//        for (int i = 0;i < s;i++) {
//            Handler handler = tmpExecutionHandlers[i];


191226
Block.java rem
    // getAABB() or getAABBs() ? now just as a const CubeBox
//    public void getAABBs(BlockState blockState, Vector3f blockPos, Octree octree, List<AABB> aabbs) {
//        float size = octree.size();
//        AABB aabb = new AABB();
//        aabb.min.set(blockPos);
//        aabb.max.set(blockPos).add(size, size, size);
//
//        aabbs.add(aabb);
//    }


Outskirts.java

//        {   //draw splash screen
//            Gui.drawRect(Colors.DARK_BLUE, 0, 0, getWidth(), getHeight());
//            Gui.drawString("INIT PHASE..", 16, getHeight() - 80, Colors.BLUE, 32);
//            this.updateDisplay();
//        }


    private void stepdelta(Vector3f vec) {
        if (SystemUtils.isCtrlKeyDown()) {
            float spd = 0.1f;
            if (Keyboard.isKeyDown(Keyboard.KEY_W)) {
                vec.z -= spd;
            }
            if (Keyboard.isKeyDown(Keyboard.KEY_S)) {
                vec.z += spd;
            }
            if (Keyboard.isKeyDown(Keyboard.KEY_A)) {
                vec.x -= spd;
            }
            if (Keyboard.isKeyDown(Keyboard.KEY_D)) {
                vec.x += spd;
            }
            if (Keyboard.isKeyDown(Keyboard.KEY_SPACE)) {
                vec.y += spd;
            }
            if (Keyboard.isKeyDown(Keyboard.KEY_LSHIFT)) {
                vec.y -= spd;
            }
        }
    }




    20200113

          // validation of the program could not be performed, because no Vertex Array Object is bound
//        glValidateProgram(programID);
//        if (glGetProgrami(programID, GL_VALIDATE_STATUS) == GL_FALSE) {
//            Log.warn("##### GL Program Validate Error #####");
//            Log.warn(glGetProgramInfoLog(programID, 1024));
//            throw new IllegalStateException("GL Program Validate Error");
//        }


20200116

CollectionUtils

insertionSort() rem
//              for (int j = i;j >= 1 && c.compare(list.get(j-1), list.get(j)) > 0;j--) swap(list, j-1, j);



    //should blockPos.w be depth or size ..? ,depth can get size directly(arr[int])



20020205 ChannelHandler:


    /**
     * both Server AND Client connections (for checking conn status
     */
    private static final List<ChannelHandler> connections = new ArrayList<>();

    static {
        Thread t = new Thread(() -> {
            while (true) {

                Iterator<ChannelHandler> it = connections.iterator();
                while (it.hasNext()) {
                    ChannelHandler conn = it.next();

                    if (!conn.isChannelOpen()) {
                        it.remove();
                        conn.eventBus().post(new DisconnectEvent());
                    }
                }

                SystemUtils.sleep(20);
            }
        }, "ConnectionCheckr");
        t.setDaemon(true);
        t.start();
    }


    in channelInitializer():
                        synchronized (connections) {
                            connections.add(channelHandler);
                        }



200207 Entity
// in the system, EulerAngles total is x:Pitch, y:Yaw, z:Roll, and order is [outer> Y>X>Z >inner], this is supports camera common working.

Registry

    //RegistryID always is String, but sometimes not, e.g Packet registerID is Integer, it needs more simple data

Validate.validState(getRegistryID(entry) == null, "Registration %s(registryID='%s') is already been registered.", entry.toString(), registryID);

    /**
     * this'll useful when registration no storage registryID
     */
    public <I> I getRegistryID(T entry) {
        for (Map.Entry<Object, T> e : map.entrySet()) {
            if (e.getValue().equals(entry))
                return (I) e.getKey();
        }
        return null;
    }





    private void handleInput() {
        mouseDWheel = 0;
        mouseDY = 0;
        mouseDX = 0;
//        while (Mouse.next()) {
//            mouseDWheel = Mouse.getEventDWheel();
//            mouseDY = -Mouse.getEventDY();
//            mouseDX =  Mouse.getEventDX();
//            mouseY = Display.getHeight() - Mouse.getEventY();
//            mouseX = Mouse.getEventX();
//
//            Events.EVENT_BUS.post(new MouseEvent());
//
//            KeyBinding.postInput(Mouse.getEventButton(), Mouse.getEventButtonState(), KeyBinding.TYPE_MOUSE);
//
//            rootGUI.onMouse(Mouse.getEventButton(), Mouse.getEventButtonState());
//        }
//
//        while (Keyboard.next()) {
//
//            Events.EVENT_BUS.post(new KeyboardEvent());
//
//            KeyBinding.postInput(Keyboard.getEventKey(), Keyboard.getEventKeyState(), KeyBinding.TYPE_KEYBOARD);
//
//            rootGUI.onKeyboard(Keyboard.getEventKey(), Keyboard.getEventCharacter(), Keyboard.getEventKeyState());
//        }
    }



RigidBody.java 200318
    //deperacated
    private List<Booster> boosters = new ArrayList<>();

    public void attachBooster(Booster booster) {
        boosters.add(booster);
    }

    void performForcesBoosters(float delta) {
        for (Booster booster : boosters) {
            booster.onUpdate(this, delta);
        }
    }


CollisionObject.java ::transform
    // some not harmonious with Entity/System, like origin/position, basis/rotation diff: math/physics with actually-application





    Test 200323 MinkowskiSum Vert


        List<GuiScreen3DVertices.Vert> vertList = new ArrayList<>();

        Vector3f posoff = new Vector3f();

        // gen circle / XY coords
        posoff.set(0, 0, 0);
        for (int i = 0;i < 20;i++) {
            Matrix3f rotmat = Matrix3f.rotate(i/20f * 2*Maths.PI, Vector3f.UNIT_Z, null);
            Vector3f v = Matrix3f.transform(rotmat, new Vector3f(0, 1, 0), null).add(posoff);
            vertList.add(new GuiScreen3DVertices.Vert("circle.p"+i, v, Colors.GRAY));
        }

        // gen box
        posoff.set(1, -1, 0);
        {
            Vector3f[] varr = new Vector3f[]{new Vector3f(-1,1,0), new Vector3f(1,1,0),new Vector3f(1,-1,0),new Vector3f(-1,-1,0)};
            for (int i = 0;i < varr.length;i++) {
                vertList.add(new GuiScreen3DVertices.Vert("box.v"+i,new Vector3f(varr[i]).add(posoff),Colors.WHITE20));
            }
        }

        // gen minkSum
        int ij = 0;
        List<GuiScreen3DVertices.Vert> tmplist = new ArrayList<>(vertList);
        for (GuiScreen3DVertices.Vert v1 : tmplist) {
            for (GuiScreen3DVertices.Vert v2 : tmplist) {
                vertList.add(new GuiScreen3DVertices.Vert("", Vector3f.sub(v1.position,v2.position,null), Colors.RED));
            }
        }

        writeVerts(vertList);




Gjk.java 200324



//        Vector3f p1 = getFarthestPointWithTransform(bodyA, d,          TMP_VEC_TRANS1[0], TMP_INVROTMAT_TRANS[0]);
//        Vector3f p2 = getFarthestPointWithTransform(bodyB, d.negate(), TMP_VEC_TRANS1[1], TMP_INVROTMAT_TRANS[1]);


//    private Vector3f getFarthestPointWithTransform(CollisionObject body, Vector3f d, Vector3f dest, Matrix3f invRotMat) {
//        Vector3f originalDir = Matrix3f.transform(invRotMat, d, TMP_VEC_TRANS1[2]);
//
//        dest = ((ConvexShape)body.getCollisionShape()).getFarthestPoint(originalDir, dest);
//
//        Matrix3f.transform(body.transform().basis, dest, dest);
//        dest.add(body.transform().origin);
//        return dest;
//    }



//        TMP_INVROTMAT_TRANS[0].set(bodyA.transform().basis).invert();
//        TMP_INVROTMAT_TRANS[1].set(bodyB.transform().basis).invert();


//    private Matrix3f[] TMP_INVROTMAT_TRANS = CollectionUtils.fill(new Matrix3f[2], Matrix3f::new);


Gjk


            GuiScreen3DVertices._TMP_DEF_INST.vertices.add(new GuiScreen3DVertices.Vert("v"+i+".p", vert.point, Colors.RED));
//            GuiScreen3DVertices._TMP_DEF_INST.vertices.add(new GuiScreen3DVertices.Vert("v"+i+".onA", vert.onA, Colors.GREEN));
//            GuiScreen3DVertices._TMP_DEF_INST.vertices.add(new GuiScreen3DVertices.Vert("v"+i+".onB", vert.onB, Colors.DARK_GREEN));
//
//            GuiScreen3DVertices._TMP_DEF_INST.vertices.add(new GuiScreen3DVertices.Vert("v"+i+".dir", new Vector3f(d).normalize(), Colors.YELLOW));
//            GuiScreen3DVertices._TMP_DEF_INST.vertices.add(new GuiScreen3DVertices.Vert("", Vector3f.ZERO, Colors.YELLOW, new String[]{"v"+i+".dir"}));



                    // tmp ext.test: does the Norm facing to inner todo: eval actually ext.test
                    Vector3f ABCDCenter = new Vector3f().set(Vector3f.ZERO)
                            .add(simplex.get(A).point).add(simplex.get(B).point).add(simplex.get(C).point).add(simplex.get(D).point).scale(1/4f);
                    Vector3f DCenter = new Vector3f(ABCDCenter).sub(simplex.get(D).point);
                    if (Vector3f.dot(DCenter, ABDNorm) > 0 ) {
//                        ABDNorm.negate();
                        System.out.println("Gjk TestWarning: ABDNorm had facing to inner"+ABCDCenter.hashCode());
                    }
                    if (Vector3f.dot(DCenter, BCDNorm) > 0) {
//                        BCDNorm.negate();
                        System.out.println("Gjk TestWarning: BCDNorm had facing to inner" + ABCDCenter.hashCode());
                    }
                    if (Vector3f.dot(DCenter, CADNorm) > 0) {
//                        CADNorm.negate();
                        System.out.println("Gjk TestWarning: CADNorm had facing to inner" + ABCDCenter.hashCode());
                    }


 //Vector3f.sub(bodyA.transform().origin, bodyB.transform().origin, null);
//        if (Maths.fuzzyZero(d.lengthSquared()))
//            d.set(Vector3f.UNIT_X);


                    GuiScreen3DVertices._TMP_DEF_INST.vertices.add(new GuiScreen3DVertices.Vert("A", simplex.get(A).point, Colors.DARK_RED, new String[]{"B", "D"}));
                    GuiScreen3DVertices._TMP_DEF_INST.vertices.add(new GuiScreen3DVertices.Vert("B", simplex.get(B).point, Colors.DARK_RED, new String[]{"C", "D"}));
                    GuiScreen3DVertices._TMP_DEF_INST.vertices.add(new GuiScreen3DVertices.Vert("C", simplex.get(C).point, Colors.DARK_RED, new String[]{"A", "D"}));
                    GuiScreen3DVertices._TMP_DEF_INST.vertices.add(new GuiScreen3DVertices.Vert("D", simplex.get(D).point, Colors.DARK_RED));

                    GuiScreen3DVertices._TMP_DEF_INST.vertices.add(new GuiScreen3DVertices.Vert("ABCDCenter", ABCDCenter, Colors.DARK_RED));
                    GuiScreen3DVertices._TMP_DEF_INST.vertices.add(new GuiScreen3DVertices.Vert("DCenter", new Vector3f(simplex.get(D).point).add(DCenter), Colors.DARK_GREEN, new String[]{"D"}));
                    GuiScreen3DVertices._TMP_DEF_INST.vertices.add(new GuiScreen3DVertices.Vert("ABDNorm", new Vector3f(simplex.get(D).point).add(ABDNorm), Colors.DARK_GREEN, new String[]{"D"}));
                    GuiScreen3DVertices._TMP_DEF_INST.vertices.add(new GuiScreen3DVertices.Vert("BCDNorm", new Vector3f(simplex.get(D).point).add(BCDNorm), Colors.DARK_GREEN, new String[]{"D"}));
                    GuiScreen3DVertices._TMP_DEF_INST.vertices.add(new GuiScreen3DVertices.Vert("CADNorm", new Vector3f(simplex.get(D).point).add(CADNorm), Colors.DARK_GREEN, new String[]{"D"}));




Quaternion.java 200404
removed some rotate toolmethod. because rotate method just should gen a rotate from empty, shouldn't have the "Apply" function.
Apply rotation is always mul operation, but there always A*B != B*A, for quat and mat. so do this by self! tho some toolmethod convient and effective



    // EXTRA CRAZY DUPLICATION TOOL FUNCTION.
    // (but its fine, this is full duplicate from one src code, and this impl is private wrapped.
    //  but a lots convenient AND non heap alloc! so space effective. (except when null-dest or throw Exception.))


    // tod0: mul's left or right
    // dup from Quaternion::fromAxisAngle AND Quaternion::mul
    // == Quaternion.mul(q, Quaternion.fromAxisAngle(angle, axis, new Quaternion()))
    /**
     * integrate dest quaternion
     * e.g use for take EulerAngles to integrate/convert to a Quaternion
     */
    @SuppressWarnings("all")
    public static Quaternion rotate(float angle, Vector3f axis, Quaternion dest) {
        if (dest == null)
            dest = new Quaternion();
        // Quaternion.fromAxisAngle(axis.xyz, angle, new Quaternion())
        float s = (float) Math.sin(angle * 0.5f) / axis.length();
        float rx = axis.x * s;
        float ry = axis.y * s;
        float rz = axis.z * s;
        float rw = (float)Math.cos(angle * 0.5f);
        // Quaternion.mul(dest, aq)
        return dest.set(
                dest.x * rw + dest.w * rx + dest.y * rz - dest.z * ry,
                dest.y * rw + dest.w * ry + dest.z * rx - dest.x * rz,
                dest.z * rw + dest.w * rz + dest.x * ry - dest.y * rx,
                dest.w * rw - dest.x * rx - dest.y * ry - dest.z * rz
        );
    }

    // == Matrix3f.mul(dest, Quaternion.toMatrix(q, new Matrix3f()))
    /**
     * integrate dest Matrix3f
     * e.g use for take a Quaternion to integrate/convert a Matrix3f. like take rigidBody.angVel to Quaternion then integrate Matrix3f transform.basis
     */
    @SuppressWarnings("all")
    public static Matrix3f rotate(Quaternion q, Matrix3f dest) {
        // Quaternion.toMatrix(q, new Matrix3f())
        if (dest == null)
            dest = new Matrix3f();
        float d = q.lengthSquared();
        if (d == 0.0F)
            throw new ArithmeticException("Zero length quaternion.");
        float s = 2f / d;
        float xs = q.x * s, ys = q.y * s, zs = q.z * s;
        float wx = q.w * xs, wy = q.w * ys, wz = q.w * zs;
        float xx = q.x * xs, xy = q.x * ys, xz = q.x * zs;
        float yy = q.y * ys, yz = q.y * zs, zz = q.z * zs;

        float f00 = 1f - (yy + zz);
        float f01 = xy - wz;
        float f02 = xz + wy;
        float f10 = xy + wz;
        float f11 = 1f - (xx + zz);
        float f12 = yz - wx;
        float f20 = xz - wy;
        float f21 = yz + wx;
        float f22 = 1f - (xx + yy);

        // Matrix3f.mul(dest, f0-9)
        return Matrix3f.mul(dest, f00, f01, f02,
                                  f10, f11, f12,
                                  f20, f21, f22, dest);
    }

    // jesus crazy duplication...
    // dup from Quaternion::toMatrix AND Matrix4f::rotate's bottom's mul3x3
    // == Matrix4f.mul3x3(dest, Quaternion.toMatrix(q, new Matrix4f()))
    /**
     * integrate dest Matrix4f's 0-2 row/col (only change 9 element)
     */
    @SuppressWarnings("all")
    public static Matrix4f rotate(Quaternion q, Matrix4f dest) {
        // Quaternion.toMatrix(q, new Matrix4f())
        if (dest == null)
            dest = new Matrix4f();
        float d = q.lengthSquared();
        if (d == 0.0F)
            throw new ArithmeticException("Zero length quaternion.");
        float s = 2f / d;
        float xs = q.x * s, ys = q.y * s, zs = q.z * s;
        float wx = q.w * xs, wy = q.w * ys, wz = q.w * zs;
        float xx = q.x * xs, xy = q.x * ys, xz = q.x * zs;
        float yy = q.y * ys, yz = q.y * zs, zz = q.z * zs;

        float f00 = 1f - (yy + zz);
        float f01 = xy - wz;
        float f02 = xz + wy;
        float f10 = xy + wz;
        float f11 = 1f - (xx + zz);
        float f12 = yz - wx;
        float f20 = xz - wy;
        float f21 = yz + wx;
        float f22 = 1f - (xx + yy);

        // Matrix4f.mul3x3(dest, f0-9)
        return Matrix4f.mul3x3(dest, f00, f01, f02,
                                     f10, f11, f12,
                                     f20, f21, f22, dest);
    }


Matrix4f.java

    // #duplicated_from Matrix3f.rotate()
    @SuppressWarnings("all")
    public static Matrix4f rotate(float angle, Vector3f axis, Matrix4f dest) {
        if (dest == null)
            dest = new Matrix4f();

        float c = (float)Math.cos(angle);
        float s = (float)Math.sin(angle);
        float oneminusc = 1.0F - c;
        float xy = axis.x * axis.y;
        float yz = axis.y * axis.z;
        float xz = axis.x * axis.z;
        float xs = axis.x * s;
        float ys = axis.y * s;
        float zs = axis.z * s;

        float f00 = axis.x * axis.x * oneminusc + c;
        float f01 = xy * oneminusc - zs;
        float f02 = xz * oneminusc + ys;

        float f10 = xy * oneminusc + zs;
        float f11 = axis.y * axis.y * oneminusc + c;
        float f12 = yz * oneminusc - xs;

        float f20 = xz * oneminusc - ys;
        float f21 = yz * oneminusc + xs;
        float f22 = axis.z * axis.z * oneminusc + c;

        return mul3x3(dest, f00, f01, f02,
                            f10, f11, f12,
                            f20, f21, f22, dest);
    }

GuiScreenDebug.java rem

    private GuiText text = addGui(new GuiText()).setText("TEXT").setY(150);

        GuiText.updateTextBound(text);

        text.addOnMouseEnteredListener(e -> {
            e.gui()
                    .attachTransform(0, 200, 2, TRANS_X, IG_BACKEASE, EASE_OUT, 0)
                    .attachTransform(0, 200, 1, TRANS_Y, IG_BACKEASE, EASE_OUT, 0);
        });




SequentialImpulseCS.java 200407 rem

solveContact():
//        Vector3f angcompA = new Vector3f(); // AngularCompoundA
//        Vector3f angcompB = new Vector3f();
//        {   // contact response
//            Vector3f.cross(relpointOnA, cp.normOnB, angcompA);
//            Matrix3f.transform(bodyA.getInvInertiaTensorWorld(), angcompA, angcompA);
//
//            Vector3f.cross(relpointOnB, cp.normOnB, angcompB);
//            Matrix3f.transform(bodyB.getInvInertiaTensorWorld(), angcompB, angcompB);
//        }
//
//        // tod: test 2 way to applies Impulse -> original-common-interface or bullet customed. shuold be same effects in value.
//        bodyA.getLinearVelocity().addScaled(normalImpulse * bodyA.getInvMass(), cp.normOnB);
//        bodyA.getAngularVelocity().addScaled(normalImpulse, angcompA);
//        bodyB.getLinearVelocity().addScaled(-normalImpulse * bodyB.getInvMass(), cp.normOnB);
//        bodyB.getAngularVelocity().addScaled(-normalImpulse, angcompB);

solveFraction():
        {   // fraction tangent
            Vector3f ftorqueAxis = new Vector3f();

            // for bodyA
            Vector3f.cross(relpointOnA, cpd.frictionTangent0, ftorqueAxis);
            Matrix3f.transform(bodyA.getInvInertiaTensorWorld(), ftorqueAxis, ftorqueAxis);
            cpd.frictionAngularComponentA0.set(ftorqueAxis);

            Vector3f.cross(relpointOnA, cpd.frictionTangent1, ftorqueAxis);
            Matrix3f.transform(bodyA.getInvInertiaTensorWorld(), ftorqueAxis, ftorqueAxis);
            cpd.frictionAngularComponentA1.set(ftorqueAxis);

            // for bodyB
            Vector3f.cross(relpointOnB, cpd.frictionTangent0, ftorqueAxis);
            Matrix3f.transform(bodyB.getInvInertiaTensorWorld(), ftorqueAxis, ftorqueAxis);
            cpd.frictionAngularComponentB0.set(ftorqueAxis);

            Vector3f.cross(relpointOnB, cpd.frictionTangent1, ftorqueAxis);
            Matrix3f.transform(bodyB.getInvInertiaTensorWorld(), ftorqueAxis, ftorqueAxis);
            cpd.frictionAngularComponentB1.set(ftorqueAxis);
        }

re program

    private void prepareConstraints(RigidBody bodyA, RigidBody bodyB, CollisionManifold.ContactPoint cp, float delta) {

        Vector3f relpointA = new Vector3f(cp.pointOnA).sub(bodyA.transform().origin);
        Vector3f relpointB = new Vector3f(cp.pointOnB).sub(bodyB.transform().origin);

        Matrix3f invrotA = new Matrix3f(bodyA.transform().basis).transpose();
        Matrix3f invrotB = new Matrix3f(bodyB.transform().basis).transpose();

        CollisionManifold.ContactPoint.ConstraintSolverPresistentData cpd = cp.cpd;

        cpd.jacDiagABInv = 1f / JacobianMat.diag(
                invrotA, invrotB,
                relpointA, relpointB,
                cp.normOnB,
                new Vector3f(bodyA.getInvInertiaTensorLocalDiag()), bodyA.getInvMass(),
                new Vector3f(bodyB.getInvInertiaTensorLocalDiag()), bodyB.getInvMass());

        {
            Vector3f velA = bodyA.getVelocityInLocalPoint(relpointA, new Vector3f());
            Vector3f velB = bodyB.getVelocityInLocalPoint(relpointB, new Vector3f());
            Vector3f relvel_vec = Vector3f.sub(velA, velB, null);
            float relvel_dot_norm = Vector3f.dot(cp.normOnB, relvel_vec);

            cpd.rest_combined_restitution = Math.max(cp.combined_restitution * -relvel_dot_norm, 0); // restitutionCurve(), retuen rest
        }

        float penVel = cp.penetration / delta;  // ..?
        if (cpd.rest_combined_restitution > penVel) {
            cp.penetration = 0f; // original is cpd.penetration = 0f;
        }

        if (!useWarmStarting) {
            cpd.normalImpulseSum = 0;
        }

        // re-calculate friction direction every frame, todo: check if this is really needed
        Maths.calculateBasis(cp.normOnB, cpd.frictionTangent1, cpd.frictionTangent2);

        // non friction warm-starting
        cpd.tangentImpulseSum1 = 0f;
        cpd.tangentImpulseSum2 = 0f;

        float denom0 = bodyA.computeImpulseDenominator(cp.pointOnA, cpd.frictionTangent1);
        float denom1 = bodyB.computeImpulseDenominator(cp.pointOnB, cpd.frictionTangent1);
        cpd.jacDiagABInvTangent1 = 1f / (denom0 + denom1); // denom

        denom0 = bodyA.computeImpulseDenominator(cp.pointOnA, cpd.frictionTangent2);
        denom1 = bodyB.computeImpulseDenominator(cp.pointOnB, cpd.frictionTangent2);
        cpd.jacDiagABInvTangent2 = 1f / (denom0 + denom1); // denom


        Vector3f totalImpulse = new Vector3f(cp.normOnB).scale(cpd.normalImpulseSum);

        // apply previous frames impulse on both bodies
        bodyA.applyImpulse(totalImpulse, relpointA);
        bodyB.applyImpulse(totalImpulse.negate(), relpointB);
    }







    public void solveContact(RigidBody bodyA, RigidBody bodyB, CollisionManifold.ContactPoint cp, float delta) {

        Vector3f relpointOnA = Vector3f.sub(cp.pointOnA, bodyA.transform().origin, null);
        Vector3f relpointOnB = Vector3f.sub(cp.pointOnB, bodyB.transform().origin, null);

        Vector3f velA = bodyA.getVelocityInLocalPoint(relpointOnA, new Vector3f());
        Vector3f velB = bodyB.getVelocityInLocalPoint(relpointOnB, new Vector3f());
        Vector3f relvel = Vector3f.sub(velA, velB, null);

        float relvel_dot_norm = Vector3f.dot(cp.normOnB, relvel);

        float Kerp = 0.2F; // [0-1], always close to 0.
        float Kcor = Kerp / delta;

        CollisionManifold.ContactPoint.ConstraintSolverPresistentData cpd = cp.cpd;

        float posErr = Kcor * cp.penetration; // Kcor * distan    // Baumgarte Stabilization, b = -(beta / delta) * penetration
        float velErr = cpd.rest_combined_restitution - relvel_dot_norm;

        float penetrationImpulse = posErr * cpd.jacDiagABInv; // the LagrangeMultiplier * invJacobian, make constraintspace backto cartesianspace
        float velocityImpulse = velErr * cpd.jacDiagABInv;
        float normalImpulse = penetrationImpulse + velocityImpulse;

        // See Erin Catto's GDC 2006 paper: Clamp the accumulated impulse  // SUM(lambda[i]) >= 0
        float oldNormalImpulseSum = cpd.normalImpulseSum;
        cpd.normalImpulseSum = Math.max(oldNormalImpulseSum + normalImpulse, 0);
        normalImpulse = cpd.normalImpulseSum - oldNormalImpulseSum; // we actually added


        Vector3f imp = new Vector3f(cp.normOnB).scale(normalImpulse);
        bodyA.applyImpulse(imp,          relpointOnA);
        bodyB.applyImpulse(imp.negate(), relpointOnB);
    }


    private void solveFriction(RigidBody bodyA, RigidBody bodyB, CollisionManifold.ContactPoint cp) {

        Vector3f relpointOnA = new Vector3f(cp.pointOnA).sub(bodyA.transform().origin);
        Vector3f relpointOnB = new Vector3f(cp.pointOnB).sub(bodyB.transform().origin);

        CollisionManifold.ContactPoint.ConstraintSolverPresistentData cpd = cp.cpd;

        float limit = cpd.normalImpulseSum * cp.combined_friction;

        if (cpd.normalImpulseSum <= 0f) // non friction
            return;

        // apply friction in the 2 tangential directions

        Vector3f velA = bodyA.getVelocityInLocalPoint(relpointOnA, new Vector3f());
        Vector3f velB = bodyB.getVelocityInLocalPoint(relpointOnB, new Vector3f());
        Vector3f relvel = new Vector3f(velA).sub(velB);

        float j1,j2;
        {   // 1st tangent
            float vrel = Vector3f.dot(cpd.frictionTangent1, relvel);
            // calc j that moves us to zero relative velocity
            j1 = -vrel * cpd.jacDiagABInvTangent1;

            float oldTangentImpulseSum = cpd.tangentImpulseSum1;
            cpd.tangentImpulseSum1 = Maths.clamp(cpd.tangentImpulseSum1 + j1, -limit, limit);
            j1 = cpd.tangentImpulseSum1 - oldTangentImpulseSum;
        }
        {   // 2nd tangent
            float vrel = Vector3f.dot(cpd.frictionTangent2, relvel);
            j2 = -vrel * cpd.jacDiagABInvTangent2;

            float oldTangentImpulseSum = cpd.tangentImpulseSum2;
            cpd.tangentImpulseSum2 = Maths.clamp(cpd.tangentImpulseSum2 + j2, -limit, limit);
            j2 = cpd.tangentImpulseSum2 - oldTangentImpulseSum;
        }

        Vector3f imp = new Vector3f();

        imp.set(0,0,0);
        bodyA.applyImpulse(imp.addScaled(j1, cpd.frictionTangent1)
                              .addScaled(j2, cpd.frictionTangent2), relpointOnA);
        imp.set(0,0,0);
        bodyB.applyImpulse(imp.addScaled(-j1, cpd.frictionTangent1)
                              .addScaled(-j2, cpd.frictionTangent2), relpointOnB);

    }



    20200609
    //        if (!(bodyA.getAABB().contains(mtv.pointOnB,0.1f) && bodyB.getAABB().contains(mtv.pointOnB,0.1f))) {
    //            Outskirts.setPauseWorld(0);
    //            GuiScreen3DVertices._TMP_DEF_INST.vertices.clear();
    //            GuiScreen3DVertices._TMP_DEF_INST.vertices.add(new GuiScreen3DVertices.Vert("bodyA", bodyA.transform().origin, Colors.RED));
    //            GuiScreen3DVertices._TMP_DEF_INST.vertices.add(new GuiScreen3DVertices.Vert("bodyB", bodyB.transform().origin, Colors.RED));
    //            GuiScreen3DVertices._TMP_DEF_INST.vertices.add(new GuiScreen3DVertices.Vert("mtv.pointOnB", mtv.pointOnB, Colors.GOLD));
    //            GuiScreen3DVertices._TMP_DEF_INST.vertices.add(new GuiScreen3DVertices.Vert("mtv.normal*penDepth:"+mtv.penetration, new Vector3f(mtv.pointOnB).addScaled(mtv.penetration, mtv.normal), Colors.GOLD));
    //
    //            LOGGER.warn("illegal ContactPoint-OnB. not in both AABB of bodyA and bodyB.");
    //        }

//        GuiScreen3DVertices._TMP_DEF_INST.vertices.add(new GuiScreen3DVertices.Vert("bodyA", bodyA.transform().origin, Colors.RED));
//        GuiScreen3DVertices._TMP_DEF_INST.vertices.add(new GuiScreen3DVertices.Vert("bodyB", bodyB.transform().origin, Colors.RED));
//
//        GuiScreen3DVertices._TMP_DEF_INST.vertices.add(new GuiScreen3DVertices.Vert("mtv.pointOnB", mtv.pointOnB, Colors.GOLD));
//        GuiScreen3DVertices._TMP_DEF_INST.vertices.add(new GuiScreen3DVertices.Vert("mtv.normal*penDepth", new Vector3f(mtv.pointOnB).addScaled(mtv.penetration, mtv.normal), Colors.GOLD));


//            if (triangles.size() == 0)
//                Log.LOGGER.warn("size0, itr: {}. original_simplex: {}", itrN, simplex);


200612

                allAdded.add(new AbstractMap.SimpleEntry<>("remTri", t));

            allAdded.add(new AbstractMap.SimpleEntry<>("tri", new Triangle(edge[0], edge[1], vert)));

CollisionAlgorithmConvexConvex.java

        if (Maths.fuzzyZero(mtv.penetration)) { // touching is not passed to Epa. but there is actually closed to ZERO (floatpoint-calc-error).
            LOGGER.info("Zero penetration epa. {}", mtv.penetration);
            return false;
        }



        if (debugging) return false;

            pauseAndDebug(mtv, (RigidBody) bodyA, (RigidBody)bodyB, simplex);
            return false;

    private boolean debugging = false;
    private void pauseAndDebug(Epa.MTV mtv, RigidBody bodyA, RigidBody bodyB, List<Gjk.SupportPoint> simplex) {
        if (!debugging) {
            mtv = Epa._sta_t;
            debugging = true;
            Outskirts.setPauseWorld(0);
            GuiScreen3DVertices._TMP_DEF_INST.vertices.clear();
            GuiScreen3DVertices.addVert("Origin", Vector3f.ZERO, Colors.GOLD);
            GuiScreen3DVertices.addVert("bodyA", bodyA.transform().origin, Colors.RED);
            GuiScreen3DVertices.addVert("bodyB", bodyB.transform().origin, Colors.RED);
            GuiScreen3DVertices.addVert("mtv.pointOnB", new Vector3f(mtv.pointOnB), Colors.GOLD);
            GuiScreen3DVertices.addVert("mtv.normal*penDepth:" + mtv.penetration, new Vector3f(mtv.pointOnB).addScaled(mtv.penetration, mtv.normal), Colors.GOLD);

            // basic GJK simplex.
            GuiScreen3DVertices.addVert("sA", simplex.get(0).point, Colors.GREEN, new String[]{"sB", "sC"});
            GuiScreen3DVertices.addVert("sB", simplex.get(1).point, Colors.GREEN, new String[]{"sC"});
            GuiScreen3DVertices.addVert("sC", simplex.get(2).point, Colors.GREEN, new String[]{});
            GuiScreen3DVertices.addVert("sD", simplex.get(3).point, Colors.GREEN, new String[]{"sA", "sB", "sC"});

//            GuiScreen3DVertices.addVert("ABDNorm;dot="+Gjk.R_dotABD+";norm="+Gjk.R_ABDNorm, new Vector3f(simplex.get(3).point).addScaled(150, Gjk.R_ABDNorm), Colors.DARK_GREEN, new String[]{"sD"});
//            GuiScreen3DVertices.addVert("BCDNorm;dot="+Gjk.R_dotBCD+";norm="+Gjk.R_BCDNorm, new Vector3f(simplex.get(3).point).addScaled(150, Gjk.R_BCDNorm), Colors.DARK_GREEN, new String[]{"sD"});
//            GuiScreen3DVertices.addVert("CADNorm;dot="+Gjk.R_dotCAD+";norm="+Gjk.R_CADNorm, new Vector3f(simplex.get(3).point).addScaled(150, Gjk.R_CADNorm), Colors.DARK_GREEN, new String[]{"sD"});

            LOGGER.warn("Simplex: {}" ,simplex);
//            LOGGER.info("dotABD_BCD_CAD: {}", Gjk.dotABD_BCD_CAD);
//                LOGGER.info(Arrays.toString(Epa.SimplexABC_TriangleABC));
//                List<Gjk.SimplexVert> finalSimplex = simplex;
//                new Thread(() -> {
//                    LOGGER.info(((Epa.Triangle)Epa.allAdded.get(0).getValue()).v0);
//                    LOGGER.info(((Epa.Triangle)Epa.allAdded.get(0).getValue()).v1);
//                    LOGGER.info(((Epa.Triangle)Epa.allAdded.get(0).getValue()).v2);
//                    try {
//                        Thread.sleep(1000*10);
//                    } catch (InterruptedException e) {
//                        e.printStackTrace();
//                    }
//                    LOGGER.warn("Simplex: {}" ,finalSimplex);
//                    LOGGER.info(Arrays.toString(Epa.SimplexABC_TriangleABC));
//                    LOGGER.info(((Epa.Triangle)Epa.allAdded.get(0).getValue()).v0);
//                    LOGGER.info(((Epa.Triangle)Epa.allAdded.get(0).getValue()).v1);
//                    LOGGER.info(((Epa.Triangle)Epa.allAdded.get(0).getValue()).v2);
//                }).start();

            int i = 0;
            for (Map.Entry<String, Object> entry : Epa.allAdded) {
                switch (entry.getKey()) {
                    case "tri": {
                        Epa.Triangle t = (Epa.Triangle)entry.getValue();
                        addTri("tri"+i, t, t==mtv._t?Colors.GOLD:Colors.AQUA);
                        break;}
                    case "closestTri":{
                        Epa.Triangle t = (Epa.Triangle)entry.getValue();
                        addTri("closestTri"+i, t, Colors.YELLOW);
                        break;}
                    case "furVert":
                        GuiScreen3DVertices._TMP_DEF_INST.vertices.add(new GuiScreen3DVertices.Vert("FurVert", ((Gjk.SupportPoint)entry.getValue()).point, Colors.GOLD));
                        break;
                    case "remTri":
                        addTri("remTri"+i, (Epa.Triangle)entry.getValue(), Colors.DARK_RED);
                        break;
                }
                i++;
            }

            Transform tA = new Transform(bodyA.transform());
            Transform tB = new Transform(bodyB.transform());
            Events.EVENT_BUS.register(KeyboardEvent.class, e -> {
                if (e.getKey() == GLFW.GLFW_KEY_R && e.getKeyState()) {
//                        manifold.refreshContactPoints();
                    Outskirts.getWorld().dynamicsWorld.stepSimulation(0.1f);
                    bodyA.transform().set(tA);
                    bodyB.transform().set(tB);
                    LOGGER.warn("tA:{}, tB:{}", tA, tB);
                }
            });
        }
    }

    public static void addTri(String nmPrfx, Epa.Triangle t, Vector4f color) {
        GuiScreen3DVertices.addVert(nmPrfx+".v0", new Vector3f(t.v0.point), color, new String[]{nmPrfx+".v1", nmPrfx+".v2"});
        GuiScreen3DVertices.addVert(nmPrfx+".v1", t.v1.point, color, new String[]{nmPrfx+".v2"});
        GuiScreen3DVertices.addVert(nmPrfx+".v2", t.v2.point, color, new String[]{});

        Vector3f TCenter = new Vector3f().add(t.v0.point).add(t.v1.point).add(t.v2.point).scale(1/3f);
        GuiScreen3DVertices.Vert v = GuiScreen3DVertices.addVert("", TCenter, color);
        GuiScreen3DVertices.addVert(nmPrfx+".Norm. distan:"+t.distance+"Norm:"+t.normal,
                new Vector3f(TCenter).addScaled(30, t.normal), color, new GuiScreen3DVertices.Vert[]{v});
    }



200613

    // t0do: need fixs Bug: "almost touching" or even "Not Collision" passing to Epa from Gjk makes wrong CD result/process (almost touching penetration should ~=0.0f, but really touching 100+f)
        solved.

        Gjk.java
          // exit. when == 0 is touching, when < 0 there is non intersecting / the CSO must is out of origin

                // detect 3 Triangle-Face-Norm
                // testing: (dot >= 0) // before test, is (dot > 0) but had passing touching "penetration==0" problem. >= 0 should solve the problem, but actually waiting long-testing.
                // ;those Telorance(Eplison)(-0.001f) makes some "margin", let the "almost touching" as "not collision" or "out of Itr"...

                    // when == 0 may bodies are touching (penetration == 0 (often may not too (Simplex may not boundary) // tod0: shouldn't pass the touching




    // DEBUG
    public static Vector3f R_ABDNorm, R_BCDNorm, R_CADNorm;
    public static float R_dotABD, R_dotBCD, R_dotCAD;
    public static float dotABD_BCD_CAD;

                    R_dotABD = Vector3f.dot(ABDNorm.normalize(), DO); R_dotBCD = Vector3f.dot(BCDNorm.normalize(), DO); R_dotCAD = Vector3f.dot(CADNorm.normalize(), DO);
                    R_ABDNorm = ABDNorm; R_BCDNorm = BCDNorm; R_CADNorm = CADNorm;
                    dotABD_BCD_CAD = (Math.abs(Vector3f.dot(ABDNorm, BCDNorm)) + Math.abs(Vector3f.dot(BCDNorm, CADNorm)) + Math.abs(Vector3f.dot(CADNorm, ABDNorm))) / 3f;
//                    float f = -0.001f; // 0.02
//                    if (R_dotABD > f || R_dotBCD > f || R_dotCAD > f) {
//                        Log.LOGGER.info("Distance Too Close. not pass Gjk");
//                        throw QuickExitException.INSTANCE;
//                    }

                case 3:
                // Note that There had a Problem: face ABC might Contains/Close to the Origin. (distance 6E-5) this distance enought to make Epa failed (as SimplexNotEncloseTheOrigin).
                // so when ABC close to the Origin (AlmostTouching), just exit Gjk as NoCollision.


                    d.set(ABDNorm);  if (d.lengthSquared()==0) d.set(Vector3f.UNIT_X);  // happens when had duplicated vertex in the Simplex.


                for (SupportPoint sp1 : simplex) {
                    for (SupportPoint sp2 : simplex) {
                        if (sp1 != sp2)
                            if (sp1.point.equals(sp2.point))
                                Log.LOGGER.info("SupportPoint duplicated.");
                    }
                }

   Epa.java



//        allAdded.add(new AbstractMap.SimpleEntry<>("tri", triangles.get(1)));
//        allAdded.add(new AbstractMap.SimpleEntry<>("tri", triangles.get(2)));
//        allAdded.add(new AbstractMap.SimpleEntry<>("tri", triangles.get(3)));


//                // makesure the norm is pointing outward. when norm is pointing inward: norm.neagte()
//                if (Vector3f.dot(normal, v0.point) < 0) {
//                    normal.negate();
//                }



                    // also can set DEF as UNIT_X. but that had a problem: not related "Actually Normal" (makes distance calc as negative).
                    // also can set DEF as triangle.v0.point. this makes the norm is pointing outward and pointing to the triangle.
                    //  (and v0!=ZERO (v0 wouldn't be ZERO). cuz when v0 (a CSO-Space point) on the origin(==ZERO), CD exit as touching. wouldn't passing to Epa.)


// Setup the Distance.

                // < 0 when the DEF(UNTT_X) norm is incorrect.
                // actually distance==0 is not allowed in Epa. cuz its touching. but sometimes float-calculation-error makes lite-penetration as zero.
//                assert distance >= -0.1f : "d:"+distance;

                // distance < 0 when ABCDCenter very close to a Triangle in init-Simplex Gjk passed-in. i.e. the Simplex Tetrahedron actually is a "Plane" (4 face almost Parallel)
//                if (distance < 0) {
//                    Log.LOGGER.info("Epa distance Too Neg. {}.  Norm:{};  v0,v1,v2:{}, {}, {};  ABCDCenter: {} ", distance, normal, v0.point, v1.point, v2.point, _ABCDCenter);
////                    Log.LOGGER.info("Epa distance Too Neg. {}.  Norm:{};  v0,v1,v2:{}, {}, {};  ABCDCenter: {}  dotAvg:{}", distance, normal, v0.point, v1.point, v2.point, _ABCDCenter, Gjk.dotABD_BCD_CAD);
//                    Epa._sta_t = MTV.fromClosestTriangle(this);
//                    throw QuickExitException.INSTANCE;
//                }


        public Triangle _t;
            mtv._t = trig;

    public static List<Map.Entry<String, Object>> allAdded = new ArrayList<>();
    public static MTV _sta_t;

        allAdded.clear();
            allAdded.add(new AbstractMap.SimpleEntry<>("closestTri", trig));
            allAdded.add(new AbstractMap.SimpleEntry<>("furVert", furSp));


            allAdded.add(new AbstractMap.SimpleEntry<>("tri", this));


200615

QuickHull.java



        ++ctr;
        List<GuiScreen3DVertices.Vert> vs = GuiScreen3DVertices.addTri("hull"+ctr, A, B, C, Colors.YELLOW, ABCNorm);

        GuiScreen3DVertices.Vert v = GuiScreen3DVertices.addVert("hull"+ctr+".P", P, Colors.GOLD);

//            vertices.removeAll(pointsInfront);


        GuiScreen3DVertices._TMP_DEF_INST.vertices.remove(v);
        GuiScreen3DVertices._TMP_DEF_INST.vertices.removeAll(vs);



 200618

 BroadphaseDbvt.java



//    private void collideTT(DbvtNode rt1, DbvtNode rt2) {
//        LinkedList<Pair<DbvtNode, DbvtNode>> stack = new LinkedList<>();
//        stack.push(new Pair<>(rt1, rt2));
//        while (!stack.isEmpty()) {
//            Pair<DbvtNode, DbvtNode> p = stack.pop();
//            if (AABB.intersects(p.A.volume, p.B.volume)) {
//                if (p.A.isInternal()) {
//                    if (p.B.isInternal()) {
//                        stack.push(new Pair<>(p.A.child[0], p.B.child[0]));
//                        stack.push(new Pair<>(p.A.child[0], p.B.child[1]));
//                        stack.push(new Pair<>(p.A.child[1], p.B.child[0]));
//                        stack.push(new Pair<>(p.A.child[1], p.B.child[1]));
//                    } else {
//                        stack.push(new Pair<>(p.A.child[0], p.B));
//                        stack.push(new Pair<>(p.A.child[1], p.B));
//                    }
//                } else {
//                    if (p.B.isInternal()) {
//                        stack.push(new Pair<>(p.A, p.B.child[0]));
//                        stack.push(new Pair<>(p.A, p.B.child[1]));
//                    } else {
//                        overlappingPairs.add(new CollisionManifold((RigidBody)p.A.body, (RigidBody)p.B.body));
//                    }
//                }
//            }
//        }
//    }




    private void collideTo(DbvtNode node, AABB volume, Consumer<DbvtNode> onCollidedLeaf) {
        if (!AABB.intersects(node.volume, volume))
            return;
        if (node.isLeaf()) {
            onCollidedLeaf.accept(node);
        } else {
            collideTo(node.child[0], volume, onCollidedLeaf);
            collideTo(node.child[1], volume, onCollidedLeaf);
        }
    }